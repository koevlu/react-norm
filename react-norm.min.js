"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("react"),r={currentUpdatedAt:Date.now(),suspensePromises:new Map,updatedAt:new Map,ormsById:new Map,parents:new Map,ormKeys:new Map,items:new Map,ids:new Map,childs:new Map,fetchedAt:new Map,refreshes:new Map,arrayChilds:new Map,refetchingPromises:new Map,descriptions:(e=new Map,e.get=t=>{const r=Map.prototype.get.call(e,t);return"function"==typeof r&&e.set(t,r()),Map.prototype.get.call(e,t)},e)};const s=(e,...t)=>{for(const r of t)e.set(r,e.has(r)?e.get(r):new Map),e=e.get(r);return e},n=(e,...t)=>{const r=t.pop();return s(e,...t).get(r)},o=(e,...t)=>r=>{const n=t.pop();return s(e,...t).set(n,r),r},i=(e,...t)=>{const r=t.pop(),n=s(e,...t),o=n.get(r)?n.get(r):1;n.set(r,o)},d=(e,...t)=>{const r=t.pop(),n=s(e,...t),o=e.get(r)-1;o?n.set(r,o):n.delete(r)};let a=0;const u=(e,t,s)=>{const i=n(r.ids,e,t,s)||Symbol.for("normId "+a++);o(r.ids,e,t,s)(i);const d=r.items.get(i);if(!h(d))return i;for(let t of r.ormKeys.get(e))d.hasOwnProperty(t)&&o(r.ids,e,t,d[t])(i);return i},p=(e,...t)=>{for(let s of r.ormKeys.get(e)){const e=t.find((e=>h(e)&&e.hasOwnProperty(s)));if(e)return{idKey:s,id:e[s]}}},c=(e,t)=>{if(!t)return;r.updatedAt.get(e)<r.currentUpdatedAt?(o(r.childs,t,e)(1),o(r.parents,e,t)(1)):(i(r.childs,t,e),i(r.parents,e,t))},f=(e,t)=>{t&&(d(r.parents,e,t),d(r.childs,t,e))},l=e=>{const t=new Map;for(let r of e.keys())y(r,t)},y=(e,t)=>{if(t.has(e))return;r.refreshes.set(e,!0),t.set(e,!0);const s=r.parents.get(e);if(s)for(let e of s.keys())y(e,t)},m=e=>r.descriptions.has(e),h=e=>e&&Object.getPrototypeOf(e)===Object.getPrototypeOf({}),g=(e,t)=>"function"==typeof e?e(t):e,w=e=>e&&"function"==typeof e.then,A=e=>{const t=r.items.get(e);if(!r.refreshes.has(e))return t;const s=r.ormsById.get(e),n=r.descriptions.get(s),o=Array.isArray(n)?[]:h(n)?{}:t;return r.items.set(e,o),r.refreshes.delete(e),M(n,t,o)},M=(e,t,r)=>{if(m(e)){const{idKey:r,id:s}=p(e,t),n=u(e,r,s);return A(n)}if(h(e)){if(!h(t))return t;for(let s in t)r[s]=M(e[s],t[s]);return r}if(Array.isArray(e)){if(!Array.isArray(t))return t;r=r||[];for(let s=0;t.length>s;s++)r[s]=M(e[0],t[s]);return r}return t},K=new Map,O=(e,t)=>{o(K,e,t)(!0);return()=>((e,...t)=>{const r=t.pop(),s=n(e,...t),o=s.get(r);return s.delete(r),o})(K,e,t)},I=e=>{const t=K.get(e);if(t)for(let e of t.keys())e()},S=e=>{for(let t of K.keys())(e.has(t)||r.refreshes.has(t))&&I(t)};let P=!1,B=new Map;const v=(e,t,r,s)=>{if(!e)return t;if(m(e))return t===A(r)?(P=!0,null):t;if(h(e)){const s={};for(let n in t)s[n]=v(e[n],t[n],r);return P?s:t}if(Array.isArray(e)&&Array.isArray(t)){if(!m(e[0]))return t;const n=new Map,o=t.filter((t=>{const{idKey:s,id:o}=p(e[0],t),i=u(e[0],s,o);return n.set(i,!0),t!==A(r)||(P=!0,!1)}));if(P)return U(t,o,n,s),o}return t},U=(e,t,s,n)=>{const o=r.arrayChilds.get(e);if(r.arrayChilds.set(t,s),o)for(let e of o.keys())s.has(e)||f(e,n)},b=[];let k=new Map,x=new Map;const D=(e,t,s)=>{r.currentUpdatedAt=Date.now(),s=g(s,A(t)),k=new Map,x=new Map;const n=j(e,t,s,null);return((e,t)=>{for(let s of t.keys()){const n=t.get(s);for(let t of n){const n=t.findIndex((e=>e===s));let o=r.items.get(s),i=n+1;for(;t.length>i;){const s=t[i++],n=t[i];if(e.has(n)){const e=r.items.get(n);o[s]=e,o=e,++i}else o=o[s]}}}})(x,k),l(x),S(x),n},j=(e,t,s,n)=>{const o=A(t);if(r.ormsById.set(t,e),x.get(t)){const e=k.get(t),s=[...b,t];return e?e.push(s):k.set(t,[s]),c(t,n),r.items.get(t)}if(s===o)return o;if(x.set(t,!0),r.updatedAt.set(t,r.currentUpdatedAt),!s)return o&&(r.items.set(t,s),f(t,n)),s;b.push(t),r.refreshes.delete(t),c(t,n);const i=Array.isArray(s)?[]:h(s)?{}:s;return r.items.set(t,i),C(r.descriptions.get(e),o,s,t,i),b.pop(),i},C=(e,t,r,s,n)=>{if(!(r=g(r,t)))return r;if(m(e)){const{idKey:n,id:o}=p(e,r,t),i=u(e,n,o);return j(e,i,r,s)}if(h(r)&&h(n)){for(let o in r){const i=e&&e[o],d=t&&t[o];b.push(o),n[o]=C(i,d,r[o],s,n),b.pop()}if(h(t)&&h(n))for(let o in t)if(!r.hasOwnProperty(o)){const r=e&&e[o],i=t&&t[o];b.push(o),n[o]=C(r,i,i,s),b.pop()}return n}if(Array.isArray(r)&&Array.isArray(e)){const o=Array.isArray(n)?n:[],i=e[0],d=new Map;return r.forEach(((e,t)=>{const{idKey:r,id:n}=p(i,e),a=u(i,r,n);d.set(a,!0),b.push(t),o[t]=j(i,a,e,s),b.pop()})),U(t,o,d,s),o}return r};let L=["id"],z=0;const E=e=>{const t={put:(e,r,s)=>{const n={idKey:"id",...s},o=u(t,n.idKey,e);return D(t,o,r)},get:(e,r)=>{const s={idKey:"id",...r},n=u(t,s.idKey,e);return A(n)},replace:(e,s,n)=>{const o={idKey:"id",...n};return((e,t)=>{r.items.set(e,t),r.currentUpdatedAt=Date.now(),r.updatedAt.set(e,r.currentUpdatedAt);const s=(new Map).set(e,!0);return l(s),S(s),t})(u(t,o.idKey,e),s)},remove:(e,s)=>{const n={idKey:"id",...s};return(e=>{r.currentUpdatedAt=Date.now(),B=new Map,B.set(e,!0);const t=A(e),s=r.parents.get(e);for(let t of s.keys()){B.set(t,!0);const s=A(t),n=r.ormsById.get(t),o=r.descriptions.get(n);let i;if(h(o)){i={};for(let n in s)i[n]=v(o[n],s[n],e,t),P&&(r.childs.get(t).delete(e),P=!1)}Array.isArray(o)&&(i=s.filter((s=>{const{idKey:n,id:i}=p(o[0],s);return u(o[0],n,i)!==e||(r.childs.get(t).delete(e),!1)}))),r.items.set(t,i),r.updatedAt.set(t,r.currentUpdatedAt)}return r.items.set(e,null),r.ormsById.delete(e),r.childs.delete(e),r.parents.delete(e),r.suspensePromises.delete(e),r.updatedAt.delete(e),r.refreshes.delete(e),l(B),S(B),t})(u(t,n.idKey,e))},num:z++};return r.descriptions.set(t,e),r.ormKeys.set(t,L),L=["id"],t};E.byKeys=(...e)=>(L=e,E);const _=Symbol("loader"),q={idKey:"id",lifetimeMs:216e6,suspense:!0};let T=0;const F=(e,t,s,n)=>{const o=!n.suspense||r.fetchedAt.has(t)||r.suspensePromises.has(t)?r.refetchingPromises:r.suspensePromises,i=s.then((s=>{if(o.get(t)!==i)throw"canceled";return o.delete(t),r.fetchedAt.set(t,Date.now()),G(),H(e,t,s)}),(e=>{if(o.get(t)!==i)throw"canceled";throw o.delete(t),G(),e}));return o.set(t,i),I(t),G(),i},G=()=>{const e=0!==r.suspensePromises.size||0!==r.refetchingPromises.size;setTimeout((()=>D(null,_,e)),0)},H=(e,t,s)=>{const n=r.ormsById.get(e.id),o=D(n,t,e.isOrmStore?s:{id:t,value:s});return e.isOrmStore?o:o.value},J=(e,t,s)=>{const n=e.isOrmStore?s[0]:e.id,o=e.isOrmStore?s[1]:s[0],i=e.isOrmStore?s[2]:s[1],d=r.ormsById.get(e.id),a={...t,...i};return{normId:e.isOrmStore?u(d,a.idKey,n):e.id,options:a,diff:o}},N=(e,t,s)=>{const n=e.isOrmStore?s[0]:e.id,o=e.isOrmStore?s[2]:s[1],i=r.ormsById.get(e.id),d={...t,...o};return{normId:e.isOrmStore?u(i,d.idKey,n):e.id}},Q=(e,r)=>{const s=R(e);t.useEffect((()=>{const t=()=>r(R(e));return s!==R(e)&&t(),O(e,t)}),[e,s,r])},R=e=>r.suspensePromises.get(e)||A(e),V=(e,t,s)=>{const n={idKey:"id",...e.isOrmStore?s:t},o=r.ormsById.get(e.id);return{store:e,normId:e.isOrmStore?u(o,n.idKey,t):e.id}};exports.orm=E,exports.store=(e,t,s)=>{const n={...q,...s},o=m(e),i=Symbol.for("store "+T++),d={id:i,isOrmStore:o,put:(...e)=>{const{normId:t,diff:r,options:s}=J(d,n,e);return w(r)?F(d,t,r,s):H(d,t,r)},get:(...e)=>{const{normId:t}=N(d,n,e),s=A(t);return r.suspensePromises.get(t)||(o?s:s.value)},isLoading:(...e)=>{const{normId:t}=N(d,n,e);return r.suspensePromises.has(t)||r.refetchingPromises.has(t)},wasLoaded:(...e)=>{const{normId:t}=N(d,n,e);return r.fetchedAt.has(t)}};return r.ormsById.set(i,o?e:E({value:e})),o||d.put(t),d},exports.useLoading=()=>{const[e,r]=t.useState(!1);return Q(_,(t=>t!==e&&r(t))),e},exports.useStore=(...e)=>{const{store:r,normId:s}=V(...e),[n,o]=t.useState(R(s));if(Q(s,o),w(n))throw n;return r.isOrmStore?n:n.value};
